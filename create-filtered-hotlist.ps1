Import-Module ImportExcel -ErrorAction SilentlyContinue# Set working directory$currentDir = Get-Location# Prompt for input file$inputFile = Read-Host "Enter the spreadsheet filename (e.g., users.csv or users.xlsx)"$inputPath = Join-Path -Path $currentDir -ChildPath $inputFileif (-not (Test-Path $inputPath)) {    Write-Error "❌ File not found: $inputPath"    exit}# Prompt for profile image folder$imageFolderName = Read-Host "Enter the folder name with profile pictures"$imageFolder = Join-Path -Path $currentDir -ChildPath $imageFolderNameif (-not (Test-Path $imageFolder)) {    Write-Error "❌ Folder not found: $imageFolder"    exit}# Prompt for username column (default = "username")$usernameCol = Read-Host "Enter the column header for the username (default: username)"if ([string]::IsNullOrWhiteSpace($usernameCol)) { $usernameCol = "username" }# Case sensitivity option$caseSensitive = Read-Host "Should matching be case-sensitive? (y/N)"$useExactCase = $caseSensitive.ToLower() -eq "y"# Import file data$data =    if ($inputFile.ToLower().EndsWith(".xlsx")) {        Import-Excel -Path $inputPath    } elseif ($inputFile.ToLower().EndsWith(".csv")) {        Import-Csv -Path $inputPath    } else {        Write-Error "Unsupported file type"        exit    }# Read usernames from filenames (without extension)$usernamesInFolder = Get-ChildItem -Path $imageFolder -File |    Select-Object -ExpandProperty BaseName# Normalize for case-insensitiveif (-not $useExactCase) {    $usernamesSet = $usernamesInFolder | ForEach-Object { $_.ToLower() }    $filtered = $data | Where-Object {        $user = $_.$usernameCol        $user -and ($usernamesSet -contains $user.ToLower())    }} else {    $filtered = $data | Where-Object {        $_.$usernameCol -in $usernamesInFolder    }}# Get list of columns$columns = $filtered[0].PSObject.Properties.NameWrite-Host "`nAvailable columns:"for ($i = 0; $i -lt $columns.Count; $i++) {    Write-Host "$($i + 1): $($columns[$i])"}# Prompt for exclusions$excludeInput = Read-Host "Enter comma-separated column numbers to EXCLUDE (or press enter to keep all)"$excludeIndexes = @()if ($excludeInput -match '\d') {    $excludeIndexes = $excludeInput -split ',' | ForEach-Object { ($_ -as [int]) - 1 }}$columnsToKeep = for ($i = 0; $i -lt $columns.Count; $i++) {    if ($excludeIndexes -notcontains $i) {        $columns[$i]    }}# Final filtered output$final = $filtered | Select-Object -Property $columnsToKeep# Prompt for output file name and format$outputName = Read-Host "Enter the output file name (without extension, default: filtered_output)"if ([string]::IsNullOrWhiteSpace($outputName)) { $outputName = "filtered_output" }$outputType = Read-Host "Save as CSV or Excel? (csv/xlsx, default: csv)"$outputType = if ($outputType.ToLower() -eq "xlsx") { "xlsx" } else { "csv" }$outputPath = Join-Path -Path $currentDir -ChildPath "$outputName.$outputType"# Save fileif ($outputType -eq "xlsx") {    $final | Export-Excel -Path $outputPath -WorksheetName "Filtered" -AutoSize -Force} else {    $final | Export-Csv -Path $outputPath -NoTypeInformation -Force}Write-Host "`n✅ Saved: $outputPath"